#!/usr/bin/env -S uv run -s
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "anyio>=4.0.0",
#     "pydantic>=2.5.0",
# ]
# ///
"""
{{ description }}

{{ capabilities | join(', ') | title }}

This hook is designed to work with skills by validating input,
processing data, and providing structured output that skills can consume.
"""

import asyncio
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class {{ class_name }}Input(BaseModel):
    """Input schema for {{ class_name }} hook."""

    {% for field in input_fields %}
    {{ field.name }}: {{ field.type }} = Field(
        {% if field.required %}...{% else %}{{ field.default }}{% endif %},
        description="{{ field.description }}"
    )
    {% endfor %}

    # Skill integration fields
    skill_context: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Context from the calling skill"
    )
    workflow_step: Optional[str] = Field(
        default=None,
        description="Current step in the skill workflow"
    )


class {{ class_name }}Output(BaseModel):
    """Output schema for {{ class_name }} hook."""

    status: str = Field(..., description="Execution status")
    allowed: bool = Field(..., description="Whether the operation is allowed")
    data: Dict[str, Any] = Field(default_factory=dict, description="Processed data")
    message: str = Field(..., description="Status message")
    next_actions: List[str] = Field(default_factory=list, description="Suggested next actions")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


class {{ class_name }}:
    """{{ class_name }} hook for QuickHooks skill integration.

    {{ description }}

    This hook processes input data and provides structured output that
    skills can consume for further processing.
    """

    def __init__(self):
        """Initialize the hook."""
        pass

    def _validate_input_requirements(self, input_data: {{ class_name }}Input) -> tuple[bool, List[str]]:
        """Validate input requirements.

        Args:
            input_data: The input data to validate

        Returns:
            Tuple of (is_valid, error_messages)
        """
        errors = []

        {% for rule in validation_rules %}
        # {{ rule.description }}
        try:
            {% if rule.check %}
            # {{ rule.example }}
            if input_data.{{ rule.field }} {{ rule.operator }} {{ rule.value }}:
                errors.append("{{ rule.error_message }}")
            {% endif %}
            {% endif %}
        except Exception as e:
            errors.append(f"Validation error in {{ rule.name }}: {str(e)}")
        {% endfor %}

        return len(errors) == 0, errors

    def _process_data(self, input_data: {{ class_name }}Input) -> Dict[str, Any]:
        """Process the input data.

        Args:
            input_data: The input data to process

        Returns:
            Processed data dictionary
        """
        processed_data = {}

        {% for field in input_fields %}
        {% if field.name != 'skill_context' and field.name != 'workflow_step' %}
        # Extract and process {{ field.name }}
        field_value = input_data.{{ field.name }}
        if field_value is not None:
            processed_data["{{ field.name }}"] = field_value
        {% endif %}
        {% endfor %}

        # Add skill context if provided
        if input_data.skill_context:
            processed_data["skill_context"] = input_data.skill_context

        # Add workflow step if provided
        if input_data.workflow_step:
            processed_data["workflow_step"] = input_data.workflow_step

        return processed_data

    def _determine_next_actions(self, processed_data: Dict[str, Any]) -> List[str]:
        """Determine next actions based on processed data.

        Args:
            processed_data: The processed data

        Returns:
            List of suggested next actions
        """
        actions = []

        {% for action in next_actions %}
        # {{ action.condition }}
        if "{{ action.trigger }}" in str(processed_data):
            actions.append("{{ action.action }}")
        {% endfor %}

        return actions

    async def execute(self, input_data: {{ class_name }}Input) -> {{ class_name }}Output:
        """Execute the {{ class_name }} hook.

        Args:
            input_data: The input data for the hook

        Returns:
            {{ class_name }}Output: The result of the hook execution
        """
        try:
            # Validate input requirements
            is_valid, errors = self._validate_input_requirements(input_data)
            if not is_valid:
                return {{ class_name }}Output(
                    status="failed",
                    allowed=False,
                    data={},
                    message=f"Validation failed: {'; '.join(errors)}",
                    next_actions=[],
                    metadata={"validation_errors": errors}
                )

            # Process the data
            processed_data = self._process_data(input_data)

            # Determine next actions
            next_actions = self._determine_next_actions(processed_data)

            # Create metadata
            metadata = {
                "hook_name": "{{ class_name }}",
                "workflow_step": input_data.workflow_step,
                "timestamp": str(Path.cwd()),
                "processed_fields": list(processed_data.keys())
            }

            return {{ class_name }}Output(
                status="success",
                allowed=True,
                data=processed_data,
                message="{{ class_name }} processed data successfully",
                next_actions=next_actions,
                metadata=metadata
            )

        except Exception as e:
            return {{ class_name }}Output(
                status="error",
                allowed=False,
                data={},
                message=f"{{ class_name }} execution error: {str(e)}",
                next_actions=[],
                metadata={"error": str(e)}
            )


async def main():
    """Main entry point for the hook."""
    # Read input from stdin
    input_json = sys.stdin.read()

    try:
        input_data = {{ class_name }}Input.model_validate_json(input_json)
    except Exception as e:
        error_output = {
            "status": "error",
            "allowed": False,
            "data": {},
            "message": f"Invalid input: {str(e)}",
            "next_actions": [],
            "metadata": {"input_error": str(e)}
        }
        print(json.dumps(error_output, indent=2))
        sys.exit(1)

    # Create and run hook
    hook = {{ class_name }}()
    result = await hook.execute(input_data)

    # Output result
    print(json.dumps(result.model_dump(), indent=2))


if __name__ == "__main__":
    asyncio.run(main())